<body></body>
<!-- P135 - P136 -->
<script>
// 代理 Set 和 Map
// p.delete(1)
// 实际上，访问 p.size 与访问 p.delete 是不同的。这是因为 size 是属性，是一个访问器属性，而 delete 是一个方法。
// 当访问 p.size 时，访问器属性的 getter 函数会立即执行，此时我们可以通过修改 receiver 来改变 getter 函数的 this 指向。
// 而当访问 p.delete 时，delete 方法并没有执行，真正使其执行的语句是 p.delete(1) 这句函数调用。
// 因此，无论怎么修改 receiver，delete 方法执行时的 this 都会指向代理对象 p，而不会指向原始 Set 对象。
// 想要修复这个问题也不难，只需要把 delete 方法与原始数据对象绑定即可

const s = new Set([1, 2, 3])
const p = new Proxy(s, {
  get(target, key, receiver) {
    if (key === 'size') {
      return Reflect.get(target, key, target)
    }
    // 将方法与原始数据对象 target 绑定后返回
    return target[key].bind(target)
  }
})
// 调用 delete 方法删除值为 1 的元素，正确执行
p.delete(1)
</script>

<!--
<script>
// 代理 Set 和 Map
// 封装 new Proxy
</script>